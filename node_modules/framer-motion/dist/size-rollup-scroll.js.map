{"version":3,"file":"size-rollup-scroll.js","sources":["../../motion-utils/dist/es/clamp.mjs","../../motion-utils/dist/es/format-error-message.mjs","../../motion-utils/dist/es/errors.mjs","../../motion-utils/dist/es/global-config.mjs","../../motion-utils/dist/es/is-object.mjs","../../motion-utils/dist/es/noop.mjs","../../motion-utils/dist/es/pipe.mjs","../../motion-utils/dist/es/progress.mjs","../../motion-dom/dist/es/frameloop/order.mjs","../../motion-dom/dist/es/stats/buffer.mjs","../../motion-dom/dist/es/frameloop/batcher.mjs","../../motion-dom/dist/es/frameloop/render-step.mjs","../../motion-dom/dist/es/frameloop/frame.mjs","../../motion-dom/dist/es/animation/utils/is-css-variable.mjs","../../motion-dom/dist/es/value/types/numbers/index.mjs","../../motion-dom/dist/es/value/types/utils/sanitize.mjs","../../motion-dom/dist/es/value/types/utils/float-regex.mjs","../../motion-dom/dist/es/value/types/utils/single-color-regex.mjs","../../motion-dom/dist/es/value/types/color/utils.mjs","../../motion-dom/dist/es/value/types/utils/is-nullish.mjs","../../motion-dom/dist/es/value/types/color/rgba.mjs","../../motion-dom/dist/es/value/types/color/hex.mjs","../../motion-dom/dist/es/value/types/numbers/units.mjs","../../motion-dom/dist/es/value/types/color/hsla.mjs","../../motion-dom/dist/es/value/types/color/index.mjs","../../motion-dom/dist/es/value/types/utils/color-regex.mjs","../../motion-dom/dist/es/value/types/complex/index.mjs","../../motion-dom/dist/es/value/types/color/hsla-to-rgba.mjs","../../motion-dom/dist/es/utils/mix/immediate.mjs","../../motion-dom/dist/es/utils/mix/number.mjs","../../motion-dom/dist/es/utils/mix/color.mjs","../../motion-dom/dist/es/utils/mix/visibility.mjs","../../motion-dom/dist/es/utils/mix/complex.mjs","../../motion-dom/dist/es/utils/mix/index.mjs","../../motion-dom/dist/es/utils/interpolate.mjs","../../motion-dom/dist/es/animation/keyframes/offsets/default.mjs","../../motion-dom/dist/es/animation/keyframes/offsets/fill.mjs","../../motion-dom/dist/es/utils/supports/flags.mjs","../../motion-dom/dist/es/utils/supports/memo.mjs","../../motion-utils/dist/es/memo.mjs","../../motion-dom/dist/es/utils/supports/scroll-timeline.mjs","../../motion-dom/dist/es/utils/is-html-element.mjs","../../motion-dom/dist/es/resize/handle-element.mjs","../../motion-dom/dist/es/utils/is-svg-element.mjs","../../motion-dom/dist/es/utils/resolve-elements.mjs","../../motion-dom/dist/es/resize/handle-window.mjs","../../motion-dom/dist/es/scroll/observe.mjs","../lib/render/dom/scroll/info.js","../../motion-utils/dist/es/velocity-per-second.mjs","../lib/render/dom/scroll/offsets/edge.js","../lib/render/dom/scroll/offsets/offset.js","../lib/render/dom/scroll/offsets/presets.js","../lib/render/dom/scroll/offsets/index.js","../lib/render/dom/scroll/offsets/inset.js","../lib/render/dom/scroll/on-scroll-handler.js","../lib/render/dom/scroll/track.js","../../motion-dom/dist/es/resize/index.mjs","../lib/render/dom/scroll/utils/get-timeline.js","../lib/render/dom/scroll/utils/can-use-native-timeline.js","../lib/render/dom/scroll/index.js","../lib/render/dom/scroll/attach-function.js","../lib/render/dom/scroll/attach-animation.js"],"sourcesContent":["const clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\nexport { clamp };\n//# sourceMappingURL=clamp.mjs.map\n","function formatErrorMessage(message, errorCode) {\n    return errorCode\n        ? `${message}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}`\n        : message;\n}\n\nexport { formatErrorMessage };\n//# sourceMappingURL=format-error-message.mjs.map\n","import { formatErrorMessage } from './format-error-message.mjs';\n\nlet warning = () => { };\nlet invariant = () => { };\nif (typeof process !== \"undefined\" &&\n    process.env?.NODE_ENV !== \"production\") {\n    warning = (check, message, errorCode) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(formatErrorMessage(message, errorCode));\n        }\n    };\n    invariant = (check, message, errorCode) => {\n        if (!check) {\n            throw new Error(formatErrorMessage(message, errorCode));\n        }\n    };\n}\n\nexport { invariant, warning };\n//# sourceMappingURL=errors.mjs.map\n","const MotionGlobalConfig = {};\n\nexport { MotionGlobalConfig };\n//# sourceMappingURL=global-config.mjs.map\n","function isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\nexport { isObject };\n//# sourceMappingURL=is-object.mjs.map\n","/*#__NO_SIDE_EFFECTS__*/\nconst noop = (any) => any;\n\nexport { noop };\n//# sourceMappingURL=noop.mjs.map\n","/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nexport { pipe };\n//# sourceMappingURL=pipe.mjs.map\n","/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nexport { progress };\n//# sourceMappingURL=progress.mjs.map\n","const stepsOrder = [\n    \"setup\", // Compute\n    \"read\", // Read\n    \"resolveKeyframes\", // Write/Read/Write/Read\n    \"preUpdate\", // Compute\n    \"update\", // Compute\n    \"preRender\", // Compute\n    \"render\", // Write\n    \"postRender\", // Compute\n];\n\nexport { stepsOrder };\n//# sourceMappingURL=order.mjs.map\n","const statsBuffer = {\n    value: null,\n    addProjectionMetrics: null,\n};\n\nexport { statsBuffer };\n//# sourceMappingURL=buffer.mjs.map\n","import { MotionGlobalConfig } from 'motion-utils';\nimport { stepsOrder } from './order.mjs';\nimport { createRenderStep } from './render-step.mjs';\n\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    const flagRunNextFrame = () => (runNextFrame = true);\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);\n        return acc;\n    }, {});\n    const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender, } = steps;\n    const processBatch = () => {\n        const timestamp = MotionGlobalConfig.useManualTiming\n            ? state.timestamp\n            : performance.now();\n        runNextFrame = false;\n        if (!MotionGlobalConfig.useManualTiming) {\n            state.delta = useDefaultElapsed\n                ? 1000 / 60\n                : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        }\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        setup.process(state);\n        read.process(state);\n        resolveKeyframes.process(state);\n        preUpdate.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => {\n        for (let i = 0; i < stepsOrder.length; i++) {\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return { schedule, cancel, state, steps };\n}\n\nexport { createRenderBatcher };\n//# sourceMappingURL=batcher.mjs.map\n","import { statsBuffer } from '../stats/buffer.mjs';\n\nfunction createRenderStep(runNextFrame, stepName) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    let numCalls = 0;\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        numCalls++;\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            /**\n             * If we're recording stats then\n             */\n            if (stepName && statsBuffer.value) {\n                statsBuffer.value.frameloop[stepName].push(numCalls);\n            }\n            numCalls = 0;\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n//# sourceMappingURL=render-step.mjs.map\n","import { noop } from 'motion-utils';\nimport { createRenderBatcher } from './batcher.mjs';\n\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\n\nexport { cancelFrame, frame, frameData, frameSteps };\n//# sourceMappingURL=frame.mjs.map\n","const checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = \n/*@__PURE__*/ checkStringStartsWith(\"--\");\nconst startsAsVariableToken = \n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\nconst isCSSVariableToken = (value) => {\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken)\n        return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n/**\n * Check if a value contains a CSS variable anywhere (e.g. inside calc()).\n * Unlike isCSSVariableToken which checks if the value IS a var() token,\n * this checks if the value CONTAINS var() somewhere in the string.\n */\nfunction containsCSSVariable(value) {\n    if (typeof value !== \"string\")\n        return false;\n    // Strip comments to avoid false positives\n    return value.split(\"/*\")[0].includes(\"var(--\");\n}\n\nexport { containsCSSVariable, isCSSVariableName, isCSSVariableToken };\n//# sourceMappingURL=is-css-variable.mjs.map\n","import { clamp } from 'motion-utils';\n\nconst number = {\n    test: (v) => typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\nexport { alpha, number, scale };\n//# sourceMappingURL=index.mjs.map\n","// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\n\nexport { sanitize };\n//# sourceMappingURL=sanitize.mjs.map\n","const floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\n\nexport { floatRegex };\n//# sourceMappingURL=float-regex.mjs.map\n","const singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n\nexport { singleColorRegex };\n//# sourceMappingURL=single-color-regex.mjs.map\n","import { floatRegex } from '../utils/float-regex.mjs';\nimport { isNullish } from '../utils/is-nullish.mjs';\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((typeof v === \"string\" &&\n        singleColorRegex.test(v) &&\n        v.startsWith(type)) ||\n        (testProp &&\n            !isNullish(v) &&\n            Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (typeof v !== \"string\")\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\nexport { isColorString, splitColor };\n//# sourceMappingURL=utils.mjs.map\n","function isNullish(v) {\n    return v == null;\n}\n\nexport { isNullish };\n//# sourceMappingURL=is-nullish.mjs.map\n","import { clamp } from 'motion-utils';\nimport { number, alpha } from '../numbers/index.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: /*@__PURE__*/ isColorString(\"rgb\", \"red\"),\n    parse: /*@__PURE__*/ splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\n        rgbUnit.transform(red) +\n        \", \" +\n        rgbUnit.transform(green) +\n        \", \" +\n        rgbUnit.transform(blue) +\n        \", \" +\n        sanitize(alpha.transform(alpha$1)) +\n        \")\",\n};\n\nexport { rgbUnit, rgba };\n//# sourceMappingURL=rgba.mjs.map\n","import { rgba } from './rgba.mjs';\nimport { isColorString } from './utils.mjs';\n\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: /*@__PURE__*/ isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nexport { hex };\n//# sourceMappingURL=hex.mjs.map\n","/*#__NO_SIDE_EFFECTS__*/\nconst createUnitType = (unit) => ({\n    test: (v) => typeof v === \"string\" && v.endsWith(unit) && v.split(\" \").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = /*@__PURE__*/ createUnitType(\"deg\");\nconst percent = /*@__PURE__*/ createUnitType(\"%\");\nconst px = /*@__PURE__*/ createUnitType(\"px\");\nconst vh = /*@__PURE__*/ createUnitType(\"vh\");\nconst vw = /*@__PURE__*/ createUnitType(\"vw\");\nconst progressPercentage = /*@__PURE__*/ (() => ({\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n}))();\n\nexport { degrees, percent, progressPercentage, px, vh, vw };\n//# sourceMappingURL=units.mjs.map\n","import { alpha } from '../numbers/index.mjs';\nimport { percent } from '../numbers/units.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst hsla = {\n    test: /*@__PURE__*/ isColorString(\"hsl\", \"hue\"),\n    parse: /*@__PURE__*/ splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nexport { hsla };\n//# sourceMappingURL=hsla.mjs.map\n","import { hex } from './hex.mjs';\nimport { hsla } from './hsla.mjs';\nimport { rgba } from './rgba.mjs';\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return typeof v === \"string\"\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n    getAnimatableNone: (v) => {\n        const parsed = color.parse(v);\n        parsed.alpha = 0;\n        return color.transform(parsed);\n    },\n};\n\nexport { color };\n//# sourceMappingURL=index.mjs.map\n","const colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\n\nexport { colorRegex };\n//# sourceMappingURL=color-regex.mjs.map\n","import { color } from '../color/index.mjs';\nimport { colorRegex } from '../utils/color-regex.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\n\nfunction test(v) {\n    return (isNaN(v) &&\n        typeof v === \"string\" &&\n        (v.match(floatRegex)?.length || 0) +\n            (v.match(colorRegex)?.length || 0) >\n            0);\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = \"\";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\nexport { analyseComplexValue, complex };\n//# sourceMappingURL=index.mjs.map\n","// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\nexport { hslaToRgba };\n//# sourceMappingURL=hsla-to-rgba.mjs.map\n","function mixImmediate(a, b) {\n    return (p) => (p > 0 ? b : a);\n}\n\nexport { mixImmediate };\n//# sourceMappingURL=immediate.mjs.map\n","/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mixNumber = (from, to, progress) => {\n    return from + (to - from) * progress;\n};\n\nexport { mixNumber };\n//# sourceMappingURL=number.mjs.map\n","import { warning } from 'motion-utils';\nimport { hex } from '../../value/types/color/hex.mjs';\nimport { hsla } from '../../value/types/color/hsla.mjs';\nimport { hslaToRgba } from '../../value/types/color/hsla-to-rgba.mjs';\nimport { rgba } from '../../value/types/color/rgba.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber } from './number.mjs';\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const expo = v * (to * to - fromExpo) + fromExpo;\n    return expo < 0 ? 0 : Math.sqrt(expo);\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`, \"color-not-animatable\");\n    if (!Boolean(type))\n        return false;\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n        return mixImmediate(from, to);\n    }\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\nexport { mixColor, mixLinearColor };\n//# sourceMappingURL=color.mjs.map\n","const invisibleValues = new Set([\"none\", \"hidden\"]);\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the \"none\" or \"hidden\" string only when the progress is that of\n * the origin or target.\n */\nfunction mixVisibility(origin, target) {\n    if (invisibleValues.has(origin)) {\n        return (p) => (p <= 0 ? origin : target);\n    }\n    else {\n        return (p) => (p >= 1 ? target : origin);\n    }\n}\n\nexport { invisibleValues, mixVisibility };\n//# sourceMappingURL=visibility.mjs.map\n","import { pipe, warning } from 'motion-utils';\nimport { isCSSVariableToken } from '../../animation/utils/is-css-variable.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { mixColor } from './color.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber as mixNumber$1 } from './number.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\n\nfunction mixNumber(a, b) {\n    return (p) => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = origin.values[originIndex] ?? 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, \"complex-values-different\");\n        return mixImmediate(origin, target);\n    }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };\n//# sourceMappingURL=complex.mjs.map\n","import { getMixer } from './complex.mjs';\nimport { mixNumber } from './number.mjs';\n\nfunction mix(from, to, p) {\n    if (typeof from === \"number\" &&\n        typeof to === \"number\" &&\n        typeof p === \"number\") {\n        return mixNumber(from, to, p);\n    }\n    const mixer = getMixer(from);\n    return mixer(from, to);\n}\n\nexport { mix };\n//# sourceMappingURL=index.mjs.map\n","import { invariant, clamp, MotionGlobalConfig, noop, pipe, progress } from 'motion-utils';\nimport { mix } from './mix/index.mjs';\n\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revisit this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\", \"range-length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    if (inputLength === 2 && output[0] === output[1])\n        return () => output[1];\n    const isZeroDeltaRange = input[0] === input[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        if (isZeroDeltaRange && v < input[0])\n            return output[0];\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nexport { interpolate };\n//# sourceMappingURL=interpolate.mjs.map\n","import { fillOffset } from './fill.mjs';\n\nfunction defaultOffset(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\nexport { defaultOffset };\n//# sourceMappingURL=default.mjs.map\n","import { progress } from 'motion-utils';\nimport { mixNumber } from '../../../utils/mix/number.mjs';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mixNumber(min, 1, offsetProgress));\n    }\n}\n\nexport { fillOffset };\n//# sourceMappingURL=fill.mjs.map\n","/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {};\n\nexport { supportsFlags };\n//# sourceMappingURL=flags.mjs.map\n","import { memo } from 'motion-utils';\nimport { supportsFlags } from './flags.mjs';\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return () => supportsFlags[supportsFlag] ?? memoized();\n}\n\nexport { memoSupports };\n//# sourceMappingURL=memo.mjs.map\n","/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nexport { memo };\n//# sourceMappingURL=memo.mjs.map\n","import { memoSupports } from './memo.mjs';\n\nconst supportsScrollTimeline = /* @__PURE__ */ memoSupports(() => window.ScrollTimeline !== undefined, \"scrollTimeline\");\n\nexport { supportsScrollTimeline };\n//# sourceMappingURL=scroll-timeline.mjs.map\n","import { isObject } from 'motion-utils';\n\n/**\n * Checks if an element is an HTML element in a way\n * that works across iframes\n */\nfunction isHTMLElement(element) {\n    return isObject(element) && \"offsetHeight\" in element;\n}\n\nexport { isHTMLElement };\n//# sourceMappingURL=is-html-element.mjs.map\n","import { isSVGElement } from '../utils/is-svg-element.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nconst getSize = (borderBoxAxis, svgAxis, htmlAxis) => (target, borderBoxSize) => {\n    if (borderBoxSize && borderBoxSize[0]) {\n        return borderBoxSize[0][(borderBoxAxis + \"Size\")];\n    }\n    else if (isSVGElement(target) && \"getBBox\" in target) {\n        return target.getBBox()[svgAxis];\n    }\n    else {\n        return target[htmlAxis];\n    }\n};\nconst getWidth = /*@__PURE__*/ getSize(\"inline\", \"width\", \"offsetWidth\");\nconst getHeight = /*@__PURE__*/ getSize(\"block\", \"height\", \"offsetHeight\");\nfunction notifyTarget({ target, borderBoxSize }) {\n    resizeHandlers.get(target)?.forEach((handler) => {\n        handler(target, {\n            get width() {\n                return getWidth(target, borderBoxSize);\n            },\n            get height() {\n                return getHeight(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer?.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers?.delete(handler);\n            if (!elementHandlers?.size) {\n                observer?.unobserve(element);\n            }\n        });\n    };\n}\n\nexport { resizeElement };\n//# sourceMappingURL=handle-element.mjs.map\n","import { isObject } from 'motion-utils';\n\n/**\n * Checks if an element is an SVG element in a way\n * that works across iframes\n */\nfunction isSVGElement(element) {\n    return isObject(element) && \"ownerSVGElement\" in element;\n}\n\nexport { isSVGElement };\n//# sourceMappingURL=is-svg-element.mjs.map\n","function resolveElements(elementOrSelector, scope, selectorCache) {\n    if (elementOrSelector == null) {\n        return [];\n    }\n    if (elementOrSelector instanceof EventTarget) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            root = scope.current;\n        }\n        const elements = selectorCache?.[elementOrSelector] ??\n            root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector).filter((element) => element != null);\n}\n\nexport { resolveElements };\n//# sourceMappingURL=resolve-elements.mjs.map\n","const windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const info = {\n            get width() {\n                return window.innerWidth;\n            },\n            get height() {\n                return window.innerHeight;\n            },\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size &&\n            typeof windowResizeHandler === \"function\") {\n            window.removeEventListener(\"resize\", windowResizeHandler);\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nexport { resizeWindow };\n//# sourceMappingURL=handle-window.mjs.map\n","import { frame, cancelFrame } from '../frameloop/frame.mjs';\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.preUpdate(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nexport { observeTimeline };\n//# sourceMappingURL=observe.mjs.map\n","import { progress, velocityPerSecond } from \"motion-utils\";\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nexport const createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[`scroll${position}`];\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nexport function updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n//# sourceMappingURL=info.js.map","/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n//# sourceMappingURL=velocity-per-second.mjs.map\n","export const namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nexport function resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n//# sourceMappingURL=edge.js.map","import { namedEdges, resolveEdge } from \"./edge\";\nconst defaultOffset = [0, 0];\nexport function resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n//# sourceMappingURL=offset.js.map","export const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n//# sourceMappingURL=presets.js.map","import { defaultOffset, interpolate } from \"motion-dom\";\nimport { clamp } from \"motion-utils\";\nimport { calcInset } from \"./inset\";\nimport { resolveOffset } from \"./offset\";\nimport { ScrollOffset } from \"./presets\";\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nexport function resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n//# sourceMappingURL=index.js.map","import { isHTMLElement } from \"motion-dom\";\nexport function calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n//# sourceMappingURL=inset.js.map","import { warnOnce } from \"motion-utils\";\nimport { updateScrollInfo } from \"./info\";\nimport { resolveOffsets } from \"./offsets/index\";\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nexport function createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info);\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n//# sourceMappingURL=on-scroll-handler.js.map","import { cancelFrame, frame, frameData, resize } from \"motion-dom\";\nimport { noop } from \"motion-utils\";\nimport { createScrollInfo } from \"./info\";\nimport { createOnScrollHandler } from \"./on-scroll-handler\";\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst scrollSize = new WeakMap();\nconst dimensionCheckProcesses = new WeakMap();\nconst getEventTarget = (element) => element === document.scrollingElement ? window : element;\nexport function scrollInfo(onScroll, { container = document.scrollingElement, trackContentSize = false, ...options } = {}) {\n    if (!container)\n        return noop;\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp);\n            }\n            frame.preUpdate(notifyAll);\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify();\n            }\n        };\n        const listener = () => frame.read(measureAll);\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener);\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener);\n        listener();\n    }\n    /**\n     * Enable content size tracking if requested and not already enabled.\n     */\n    if (trackContentSize && !dimensionCheckProcesses.has(container)) {\n        const listener = scrollListeners.get(container);\n        // Store initial scroll dimensions (object is reused to avoid allocation)\n        const size = {\n            width: container.scrollWidth,\n            height: container.scrollHeight,\n        };\n        scrollSize.set(container, size);\n        // Add frame-based scroll dimension checking to detect content changes\n        const checkScrollDimensions = () => {\n            const newWidth = container.scrollWidth;\n            const newHeight = container.scrollHeight;\n            if (size.width !== newWidth || size.height !== newHeight) {\n                listener();\n                size.width = newWidth;\n                size.height = newHeight;\n            }\n        };\n        // Schedule with keepAlive=true to run every frame\n        const dimensionCheckProcess = frame.read(checkScrollDimensions, true);\n        dimensionCheckProcesses.set(container, dimensionCheckProcess);\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            resizeListeners.get(container)?.();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n        // Clean up scroll dimension checking\n        const dimensionCheckProcess = dimensionCheckProcesses.get(container);\n        if (dimensionCheckProcess) {\n            cancelFrame(dimensionCheckProcess);\n            dimensionCheckProcesses.delete(container);\n        }\n        scrollSize.delete(container);\n    };\n}\n//# sourceMappingURL=track.js.map","import { resizeElement } from './handle-element.mjs';\nimport { resizeWindow } from './handle-window.mjs';\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\nexport { resize };\n//# sourceMappingURL=index.mjs.map\n","import { scrollInfo } from \"../track\";\nimport { canUseNativeTimeline } from \"./can-use-native-timeline\";\nconst timelineCache = new Map();\nfunction scrollTimelineFallback(options) {\n    const currentTime = { value: 0 };\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis].progress * 100;\n    }, options);\n    return { currentTime, cancel };\n}\nexport function getTimeline({ source, container, ...options }) {\n    const { axis } = options;\n    if (source)\n        container = source;\n    const containerCache = timelineCache.get(container) ?? new Map();\n    timelineCache.set(container, containerCache);\n    const targetKey = options.target ?? \"self\";\n    const targetCache = containerCache.get(targetKey) ?? {};\n    const axisKey = axis + (options.offset ?? []).join(\",\");\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            canUseNativeTimeline(options.target)\n                ? new ScrollTimeline({ source: container, axis })\n                : scrollTimelineFallback({ container, ...options });\n    }\n    return targetCache[axisKey];\n}\n//# sourceMappingURL=get-timeline.js.map","import { supportsScrollTimeline } from \"motion-dom\";\nexport function canUseNativeTimeline(target) {\n    return (typeof window !== \"undefined\" && !target && supportsScrollTimeline());\n}\n//# sourceMappingURL=can-use-native-timeline.js.map","import { noop } from \"motion-utils\";\nimport { attachToAnimation } from \"./attach-animation\";\nimport { attachToFunction } from \"./attach-function\";\nexport function scroll(onScroll, { axis = \"y\", container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    const optionsWithDefaults = { axis, container, ...options };\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults);\n}\n//# sourceMappingURL=index.js.map","import { observeTimeline } from \"motion-dom\";\nimport { scrollInfo } from \"./track\";\nimport { getTimeline } from \"./utils/get-timeline\";\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll) {\n    return onScroll.length === 2;\n}\nexport function attachToFunction(onScroll, options) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis].progress, info);\n        }, options);\n    }\n    else {\n        return observeTimeline(onScroll, getTimeline(options));\n    }\n}\n//# sourceMappingURL=attach-function.js.map","import { observeTimeline } from \"motion-dom\";\nimport { getTimeline } from \"./utils/get-timeline\";\nexport function attachToAnimation(animation, options) {\n    const timeline = getTimeline(options);\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause();\n            return observeTimeline((progress) => {\n                valueAnimation.time =\n                    valueAnimation.iterationDuration * progress;\n            }, timeline);\n        },\n    });\n}\n//# sourceMappingURL=attach-animation.js.map"],"names":["clamp","min","max","v","formatErrorMessage","message","errorCode","warning","invariant","process","env","NODE_ENV","check","console","warn","Error","MotionGlobalConfig","isObject","value","noop","any","combineFunctions","a","b","pipe","transformers","reduce","progress","from","to","toFromDifference","stepsOrder","statsBuffer","addProjectionMetrics","createRenderBatcher","scheduleNextBatch","allowKeepAlive","runNextFrame","useDefaultElapsed","state","delta","timestamp","isProcessing","flagRunNextFrame","steps","acc","key","stepName","thisFrame","Set","nextFrame","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","numCalls","triggerCallback","callback","has","step","schedule","keepAlive","immediate","queue","add","cancel","delete","frameData","forEach","frameloop","push","clear","createRenderStep","setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender","processBatch","useManualTiming","performance","now","Math","i","length","frame","cancelFrame","frameSteps","requestAnimationFrame","startsAsVariableToken","token","startsWith","checkStringStartsWith","singleCssVariableRegex","number","test","parse","parseFloat","transform","alpha","sanitize","round","floatRegex","singleColorRegex","isColorString","type","testProp","Boolean","isNullish","Object","prototype","hasOwnProperty","call","splitColor","aName","bName","cName","c","match","undefined","rgbUnit","clampRgbUnit","rgba","red","green","blue","alpha$1","hex","r","g","substring","parseInt","percent","unit","endsWith","split","createUnitType","hsla","hue","saturation","lightness","color","getAnimatableNone","parsed","colorRegex","NUMBER_TOKEN","COLOR_TOKEN","complexRegex","analyseComplexValue","originalValue","toString","values","indexes","var","types","replace","parsedValue","parseComplexValue","createTransformer","source","numSections","output","convertNumbersToZero","complex","isNaN","transformer","map","hueToRgb","p","q","t","mixImmediate","mixNumber","mixLinearColor","fromExpo","expo","sqrt","colorTypes","asRGBA","find","model","hslaToRgba","mixColor","fromRGBA","toRGBA","blended","invisibleValues","mixNumber$1","getMixer","trim","mixComplex","Array","isArray","mixArray","mixObject","numValues","blendValue","origin","target","template","originStats","targetStats","mixVisibility","orderedOrigin","pointers","originIndex","originValue","matchOrder","mix","mixer","interpolate","input","isClamp","ease","inputLength","isZeroDeltaRange","reverse","mixers","customMixer","mixerFactory","numMixers","easingFunction","createMixers","interpolator","progressInRange","defaultOffset","arr","offset","remaining","offsetProgress","fillOffset","supportsFlags","memoSupports","supportsFlag","memoized","result","memo","supportsScrollTimeline","window","ScrollTimeline","isHTMLElement","element","resizeHandlers","WeakMap","observer","getSize","borderBoxAxis","svgAxis","htmlAxis","borderBoxSize","getBBox","getWidth","getHeight","notifyTarget","get","handler","width","height","notifyAll","entries","resizeElement","ResizeObserver","elements","elementOrSelector","EventTarget","document","querySelectorAll","filter","resolveElements","elementHandlers","set","observe","size","unobserve","windowCallbacks","windowResizeHandler","resizeWindow","info","innerWidth","innerHeight","addEventListener","removeEventListener","observeTimeline","timeline","prevProgress","onFrame","currentTime","keys","x","position","y","updateAxisInfo","axisName","time","axis","prev","current","prevTime","scrollLength","elapsed","velocity","frameDuration","namedEdges","start","center","end","resolveEdge","edge","inset","asNumber","documentElement","clientWidth","clientHeight","resolveOffset","containerLength","targetLength","targetInset","offsetDefinition","targetPoint","containerPoint","includes","ScrollOffset","Enter","Exit","Any","All","point","resolveOffsets","container","options","lengthLabel","offsetLeft","offsetTop","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","left","top","SVGGraphicsElement","svg","parent","parentNode","calcInset","targetSize","scrollWidth","scrollHeight","getTargetSize","containerSize","hasChanged","numOffsets","interpolatorOffsets","createOnScrollHandler","onScroll","measure","targetOffset","node","updateScrollInfo","notify","scrollListeners","resizeListeners","onScrollHandlers","scrollSize","dimensionCheckProcesses","getEventTarget","scrollingElement","scrollInfo","trackContentSize","containerHandlers","containerHandler","measureAll","listener","checkScrollDimensions","newWidth","newHeight","dimensionCheckProcess","currentHandlers","scrollListener","timelineCache","Map","getTimeline","containerCache","targetKey","targetCache","axisKey","join","scrollTimelineFallback","scroll","optionsWithDefaults","isOnScrollWithInfo","attachToFunction","animation","attachTimeline","valueAnimation","pause","iterationDuration","attachToAnimation"],"mappings":"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"}